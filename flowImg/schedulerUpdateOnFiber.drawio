<mxfile host="app.diagrams.net" modified="2022-03-18T09:35:34.857Z" agent="5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4844.51 Safari/537.36" etag="OyMI7gI3trBk3fhrga8b" version="17.1.3" type="github">
  <diagram id="C5RBs43oDa-KdzZeNtuy" name="Page-1">
    <mxGraphModel dx="2377" dy="1100" grid="1" gridSize="10" guides="1" tooltips="1" connect="1" arrows="1" fold="1" page="1" pageScale="1" pageWidth="827" pageHeight="1169" math="0" shadow="0">
      <root>
        <mxCell id="WIyWlLk6GJQsqaUBKTNV-0" />
        <mxCell id="WIyWlLk6GJQsqaUBKTNV-1" parent="WIyWlLk6GJQsqaUBKTNV-0" />
        <mxCell id="7_roHs0swbESha7kOitr-0" value="" style="rounded=0;whiteSpace=wrap;html=1;" vertex="1" parent="WIyWlLk6GJQsqaUBKTNV-1">
          <mxGeometry x="80" y="50" width="380" height="1040" as="geometry" />
        </mxCell>
        <mxCell id="7_roHs0swbESha7kOitr-1" value="&lt;div style=&quot;color: rgb(212 , 212 , 212) ; background-color: rgb(30 , 30 , 30) ; font-family: &amp;#34;menlo&amp;#34; , &amp;#34;monaco&amp;#34; , &amp;#34;courier new&amp;#34; , monospace ; font-size: 14px ; line-height: 21px&quot;&gt;&lt;span style=&quot;color: #dcdcaa&quot;&gt;scheduleUpdateOnFiber&lt;/span&gt;&lt;/div&gt;" style="text;html=1;strokeColor=none;fillColor=none;align=center;verticalAlign=middle;whiteSpace=wrap;rounded=0;" vertex="1" parent="WIyWlLk6GJQsqaUBKTNV-1">
          <mxGeometry x="101" y="60" width="160" height="20" as="geometry" />
        </mxCell>
        <mxCell id="7_roHs0swbESha7kOitr-6" style="edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;exitX=0.5;exitY=1;exitDx=0;exitDy=0;" edge="1" parent="WIyWlLk6GJQsqaUBKTNV-1" source="7_roHs0swbESha7kOitr-2" target="7_roHs0swbESha7kOitr-5">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="7_roHs0swbESha7kOitr-2" value="1. 检查是否存在无限循环的更新，比如在render中调用了setState。" style="shape=ext;double=1;rounded=0;whiteSpace=wrap;html=1;" vertex="1" parent="WIyWlLk6GJQsqaUBKTNV-1">
          <mxGeometry x="160" y="100" width="120" height="80" as="geometry" />
        </mxCell>
        <mxCell id="7_roHs0swbESha7kOitr-4" value="&lt;div style=&quot;color: rgb(212 , 212 , 212) ; background-color: rgb(30 , 30 , 30) ; font-family: &amp;#34;menlo&amp;#34; , &amp;#34;monaco&amp;#34; , &amp;#34;courier new&amp;#34; , monospace ; font-weight: normal ; font-size: 14px ; line-height: 21px&quot;&gt;&lt;div&gt;&lt;span style=&quot;color: #c586c0&quot;&gt;export&lt;/span&gt;&lt;span style=&quot;color: #d4d4d4&quot;&gt; &lt;/span&gt;&lt;span style=&quot;color: #569cd6&quot;&gt;function&lt;/span&gt;&lt;span style=&quot;color: #d4d4d4&quot;&gt; &lt;/span&gt;&lt;span style=&quot;color: #dcdcaa&quot;&gt;scheduleUpdateOnFiber&lt;/span&gt;&lt;span style=&quot;color: #d4d4d4&quot;&gt;(&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: #d4d4d4&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color: #9cdcfe&quot;&gt;fiber&lt;/span&gt;&lt;span style=&quot;color: #d4d4d4&quot;&gt;: &lt;/span&gt;&lt;span style=&quot;color: #4ec9b0&quot;&gt;Fiber&lt;/span&gt;&lt;span style=&quot;color: #d4d4d4&quot;&gt;,&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: #d4d4d4&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color: #9cdcfe&quot;&gt;lane&lt;/span&gt;&lt;span style=&quot;color: #d4d4d4&quot;&gt;: &lt;/span&gt;&lt;span style=&quot;color: #4ec9b0&quot;&gt;Lane&lt;/span&gt;&lt;span style=&quot;color: #d4d4d4&quot;&gt;,&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: #d4d4d4&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color: #9cdcfe&quot;&gt;eventTime&lt;/span&gt;&lt;span style=&quot;color: #d4d4d4&quot;&gt;: &lt;/span&gt;&lt;span style=&quot;color: #4ec9b0&quot;&gt;number&lt;/span&gt;&lt;span style=&quot;color: #d4d4d4&quot;&gt;,&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: #d4d4d4&quot;&gt;) {&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: #d4d4d4&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color: #6a9955&quot;&gt;// 第一步，检查是否有无限更新。&lt;/span&gt;&lt;span style=&quot;color: rgb(106 , 153 , 85) ; font-family: &amp;#34;menlo&amp;#34; , &amp;#34;monaco&amp;#34; , &amp;#34;courier new&amp;#34; , monospace&quot;&gt;主要是依赖于计数器count，每次调度更新就counter++ ；会在commitRoot执行后，归零count计数器。&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: #d4d4d4&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color: #dcdcaa&quot;&gt;checkForNestedUpdates&lt;/span&gt;&lt;span style=&quot;color: #d4d4d4&quot;&gt;();&lt;/span&gt;&lt;/div&gt;&lt;br&gt;&lt;div&gt;&lt;span style=&quot;color: #d4d4d4&quot;&gt;  ...&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: #d4d4d4&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color: #6a9955&quot;&gt;// 第二步，向上收集fiber.childLanes&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: #d4d4d4&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color: #569cd6&quot;&gt;const&lt;/span&gt;&lt;span style=&quot;color: #d4d4d4&quot;&gt; &lt;/span&gt;&lt;span style=&quot;color: #4fc1ff&quot;&gt;root&lt;/span&gt;&lt;span style=&quot;color: #d4d4d4&quot;&gt; = &lt;/span&gt;&lt;span style=&quot;color: #dcdcaa&quot;&gt;markUpdateLaneFromFiberToRoot&lt;/span&gt;&lt;span style=&quot;color: #d4d4d4&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color: #9cdcfe&quot;&gt;fiber&lt;/span&gt;&lt;span style=&quot;color: #d4d4d4&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color: #9cdcfe&quot;&gt;lane&lt;/span&gt;&lt;span style=&quot;color: #d4d4d4&quot;&gt;);&lt;/span&gt;&lt;/div&gt;&lt;br&gt;&lt;div&gt;&lt;span style=&quot;color: #d4d4d4&quot;&gt;  ...&lt;/span&gt;&lt;/div&gt;&lt;br&gt;&lt;div&gt;&lt;span style=&quot;color: #d4d4d4&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color: #6a9955&quot;&gt;// 第三步，在root上标记更新，将update的lane放到root.pendingLanes&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: #d4d4d4&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color: #dcdcaa&quot;&gt;markRootUpdated&lt;/span&gt;&lt;span style=&quot;color: #d4d4d4&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color: #4fc1ff&quot;&gt;root&lt;/span&gt;&lt;span style=&quot;color: #d4d4d4&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color: #9cdcfe&quot;&gt;lane&lt;/span&gt;&lt;span style=&quot;color: #d4d4d4&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color: #9cdcfe&quot;&gt;eventTime&lt;/span&gt;&lt;span style=&quot;color: #d4d4d4&quot;&gt;);&lt;/span&gt;&lt;/div&gt;&lt;br&gt;&lt;div&gt;&lt;span style=&quot;color: #d4d4d4&quot;&gt;  ...&lt;/span&gt;&lt;/div&gt;&lt;br&gt;&lt;div&gt;&lt;span style=&quot;color: #d4d4d4&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color: #6a9955&quot;&gt;// 根据Scheduler的优先级获取到对应的React优先级&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: #d4d4d4&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color: #569cd6&quot;&gt;const&lt;/span&gt;&lt;span style=&quot;color: #d4d4d4&quot;&gt; &lt;/span&gt;&lt;span style=&quot;color: #4fc1ff&quot;&gt;priorityLevel&lt;/span&gt;&lt;span style=&quot;color: #d4d4d4&quot;&gt; = &lt;/span&gt;&lt;span style=&quot;color: #dcdcaa&quot;&gt;getCurrentPriorityLevel&lt;/span&gt;&lt;span style=&quot;color: #d4d4d4&quot;&gt;();&lt;/span&gt;&lt;/div&gt;&lt;br&gt;&lt;div&gt;&lt;span style=&quot;color: #d4d4d4&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color: #c586c0&quot;&gt;if&lt;/span&gt;&lt;span style=&quot;color: #d4d4d4&quot;&gt; (&lt;/span&gt;&lt;span style=&quot;color: #9cdcfe&quot;&gt;lane&lt;/span&gt;&lt;span style=&quot;color: #d4d4d4&quot;&gt; === &lt;/span&gt;&lt;span style=&quot;color: #9cdcfe&quot;&gt;SyncLane&lt;/span&gt;&lt;span style=&quot;color: #d4d4d4&quot;&gt;) {&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: #d4d4d4&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color: #6a9955&quot;&gt;// 本次更新是同步的，例如传统的同步渲染模式&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: #d4d4d4&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color: #c586c0&quot;&gt;if&lt;/span&gt;&lt;span style=&quot;color: #d4d4d4&quot;&gt; (&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: #d4d4d4&quot;&gt;      (&lt;/span&gt;&lt;span style=&quot;color: #9cdcfe&quot;&gt;executionContext&lt;/span&gt;&lt;span style=&quot;color: #d4d4d4&quot;&gt; &amp;amp; &lt;/span&gt;&lt;span style=&quot;color: #9cdcfe&quot;&gt;LegacyUnbatchedContext&lt;/span&gt;&lt;span style=&quot;color: #d4d4d4&quot;&gt;) !== &lt;/span&gt;&lt;span style=&quot;color: #9cdcfe&quot;&gt;NoContext&lt;/span&gt;&lt;span style=&quot;color: #d4d4d4&quot;&gt; &amp;amp;&amp;amp;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: #d4d4d4&quot;&gt;      (&lt;/span&gt;&lt;span style=&quot;color: #9cdcfe&quot;&gt;executionContext&lt;/span&gt;&lt;span style=&quot;color: #d4d4d4&quot;&gt; &amp;amp; (&lt;/span&gt;&lt;span style=&quot;color: #9cdcfe&quot;&gt;RenderContext&lt;/span&gt;&lt;span style=&quot;color: #d4d4d4&quot;&gt; | &lt;/span&gt;&lt;span style=&quot;color: #9cdcfe&quot;&gt;CommitContext&lt;/span&gt;&lt;span style=&quot;color: #d4d4d4&quot;&gt;)) === &lt;/span&gt;&lt;span style=&quot;color: #9cdcfe&quot;&gt;NoContext&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: #d4d4d4&quot;&gt;    ) {&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: #d4d4d4&quot;&gt;      &lt;/span&gt;&lt;span style=&quot;color: #6a9955&quot;&gt;// 如果是本次更新是同步的，并且当前还未渲染，意味着主线程空闲，并没有React的&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: #d4d4d4&quot;&gt;      &lt;/span&gt;&lt;span style=&quot;color: #6a9955&quot;&gt;// 更新任务在执行，那么调用performSyncWorkOnRoot开始执行同步任务&lt;/span&gt;&lt;/div&gt;&lt;br&gt;&lt;div&gt;&lt;span style=&quot;color: #d4d4d4&quot;&gt;      ...&lt;/span&gt;&lt;/div&gt;&lt;br&gt;&lt;div&gt;&lt;span style=&quot;color: #d4d4d4&quot;&gt;      &lt;/span&gt;&lt;span style=&quot;color: #dcdcaa&quot;&gt;performSyncWorkOnRoot&lt;/span&gt;&lt;span style=&quot;color: #d4d4d4&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color: #4fc1ff&quot;&gt;root&lt;/span&gt;&lt;span style=&quot;color: #d4d4d4&quot;&gt;);&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: #d4d4d4&quot;&gt;    } &lt;/span&gt;&lt;span style=&quot;color: #c586c0&quot;&gt;else&lt;/span&gt;&lt;span style=&quot;color: #d4d4d4&quot;&gt; {&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: #d4d4d4&quot;&gt;      &lt;/span&gt;&lt;span style=&quot;color: #6a9955&quot;&gt;// 如果是本次更新是同步的，不过当前有React更新任务正在进行，&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: #d4d4d4&quot;&gt;      &lt;/span&gt;&lt;span style=&quot;color: #6a9955&quot;&gt;// 而且因为无法打断，所以调用ensureRootIsScheduled&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: #d4d4d4&quot;&gt;      &lt;/span&gt;&lt;span style=&quot;color: #6a9955&quot;&gt;// 目的是去复用已经在更新的任务，让这个已有的任务&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: #d4d4d4&quot;&gt;      &lt;/span&gt;&lt;span style=&quot;color: #6a9955&quot;&gt;// 把这次更新顺便做了&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: #d4d4d4&quot;&gt;      &lt;/span&gt;&lt;span style=&quot;color: #dcdcaa&quot;&gt;ensureRootIsScheduled&lt;/span&gt;&lt;span style=&quot;color: #d4d4d4&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color: #4fc1ff&quot;&gt;root&lt;/span&gt;&lt;span style=&quot;color: #d4d4d4&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color: #9cdcfe&quot;&gt;eventTime&lt;/span&gt;&lt;span style=&quot;color: #d4d4d4&quot;&gt;);&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: #d4d4d4&quot;&gt;      ...&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: #d4d4d4&quot;&gt;    }&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: #d4d4d4&quot;&gt;  } &lt;/span&gt;&lt;span style=&quot;color: #c586c0&quot;&gt;else&lt;/span&gt;&lt;span style=&quot;color: #d4d4d4&quot;&gt; {&lt;/span&gt;&lt;/div&gt;&lt;br&gt;&lt;div&gt;&lt;span style=&quot;color: #d4d4d4&quot;&gt;    ...&lt;/span&gt;&lt;/div&gt;&lt;br&gt;&lt;div&gt;&lt;span style=&quot;color: #d4d4d4&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color: #6a9955&quot;&gt;// Schedule other updates after in case the callback is sync.&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: #d4d4d4&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color: #6a9955&quot;&gt;// 如果是更新是异步的，调用ensureRootIsScheduled去进入异步调度&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: #d4d4d4&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color: #dcdcaa&quot;&gt;ensureRootIsScheduled&lt;/span&gt;&lt;span style=&quot;color: #d4d4d4&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color: #4fc1ff&quot;&gt;root&lt;/span&gt;&lt;span style=&quot;color: #d4d4d4&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color: #9cdcfe&quot;&gt;eventTime&lt;/span&gt;&lt;span style=&quot;color: #d4d4d4&quot;&gt;);&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: #d4d4d4&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color: #dcdcaa&quot;&gt;schedulePendingInteractions&lt;/span&gt;&lt;span style=&quot;color: #d4d4d4&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color: #4fc1ff&quot;&gt;root&lt;/span&gt;&lt;span style=&quot;color: #d4d4d4&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color: #9cdcfe&quot;&gt;lane&lt;/span&gt;&lt;span style=&quot;color: #d4d4d4&quot;&gt;);&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: #d4d4d4&quot;&gt;  }&lt;/span&gt;&lt;/div&gt;&lt;br&gt;&lt;div&gt;&lt;span style=&quot;color: #d4d4d4&quot;&gt;  ...&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: #d4d4d4&quot;&gt;}&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;" style="text;whiteSpace=wrap;html=1;" vertex="1" parent="WIyWlLk6GJQsqaUBKTNV-1">
          <mxGeometry x="540" y="20" width="430" height="720" as="geometry" />
        </mxCell>
        <mxCell id="7_roHs0swbESha7kOitr-9" style="edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;exitX=0.5;exitY=1;exitDx=0;exitDy=0;" edge="1" parent="WIyWlLk6GJQsqaUBKTNV-1" source="7_roHs0swbESha7kOitr-5" target="7_roHs0swbESha7kOitr-8">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="7_roHs0swbESha7kOitr-5" value="2. 向上收集fiber的lane，登记在父fiber的childLanes属性上。在render阶段，childLanes是判断fiber子树是否需要更新的关键。" style="shape=ext;double=1;rounded=0;whiteSpace=wrap;html=1;" vertex="1" parent="WIyWlLk6GJQsqaUBKTNV-1">
          <mxGeometry x="110" y="220" width="220" height="100" as="geometry" />
        </mxCell>
        <mxCell id="7_roHs0swbESha7kOitr-11" style="edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;exitX=0.5;exitY=1;exitDx=0;exitDy=0;entryX=0.5;entryY=0;entryDx=0;entryDy=0;" edge="1" parent="WIyWlLk6GJQsqaUBKTNV-1" source="7_roHs0swbESha7kOitr-8" target="7_roHs0swbESha7kOitr-10">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="7_roHs0swbESha7kOitr-8" value="3.将update的lane向上收集到root的pendingLanes上。而每次渲染优先级都是取自root.pendingLanes上最高优先级的那部分lanes" style="shape=ext;double=1;rounded=0;whiteSpace=wrap;html=1;" vertex="1" parent="WIyWlLk6GJQsqaUBKTNV-1">
          <mxGeometry x="115" y="350" width="210" height="90" as="geometry" />
        </mxCell>
        <mxCell id="7_roHs0swbESha7kOitr-17" style="edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;exitX=0.5;exitY=1;exitDx=0;exitDy=0;" edge="1" parent="WIyWlLk6GJQsqaUBKTNV-1" source="7_roHs0swbESha7kOitr-10">
          <mxGeometry relative="1" as="geometry">
            <mxPoint x="219.99999999999977" y="590" as="targetPoint" />
          </mxGeometry>
        </mxCell>
        <mxCell id="7_roHs0swbESha7kOitr-10" value="4.根据scheduler中的优先级，计算出对应的React优先级。（在一个React事件触发过程中，scheduler中的优先级是由事件优先级计算出的--- 会用runPriorityWith,来执行真正的事件回调函数。）" style="shape=ext;double=1;rounded=0;whiteSpace=wrap;html=1;" vertex="1" parent="WIyWlLk6GJQsqaUBKTNV-1">
          <mxGeometry x="122.5" y="460" width="195" height="100" as="geometry" />
        </mxCell>
        <mxCell id="7_roHs0swbESha7kOitr-22" value="同步" style="edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;exitX=1;exitY=0.5;exitDx=0;exitDy=0;" edge="1" parent="WIyWlLk6GJQsqaUBKTNV-1" source="7_roHs0swbESha7kOitr-18" target="7_roHs0swbESha7kOitr-21">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="7_roHs0swbESha7kOitr-24" style="edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;exitX=0.5;exitY=1;exitDx=0;exitDy=0;" edge="1" parent="WIyWlLk6GJQsqaUBKTNV-1" source="7_roHs0swbESha7kOitr-18" target="7_roHs0swbESha7kOitr-20">
          <mxGeometry relative="1" as="geometry">
            <Array as="points">
              <mxPoint x="175" y="690" />
            </Array>
          </mxGeometry>
        </mxCell>
        <mxCell id="7_roHs0swbESha7kOitr-25" value="异步" style="edgeLabel;html=1;align=center;verticalAlign=middle;resizable=0;points=[];" vertex="1" connectable="0" parent="7_roHs0swbESha7kOitr-24">
          <mxGeometry x="0.1709" y="-1" relative="1" as="geometry">
            <mxPoint as="offset" />
          </mxGeometry>
        </mxCell>
        <mxCell id="7_roHs0swbESha7kOitr-18" value="同步更新还是异步更新" style="rhombus;whiteSpace=wrap;html=1;" vertex="1" parent="WIyWlLk6GJQsqaUBKTNV-1">
          <mxGeometry x="150" y="590" width="140" height="100" as="geometry" />
        </mxCell>
        <mxCell id="7_roHs0swbESha7kOitr-20" value="使用ensureRootIsScheduled，来确保root会被重新调度一次更新。 （如果当前产生的更新优先级高，那么就取消之前的更新任务，以更高的优先级去调度一次更新，如果相等，则不用操作，会服用同一个更新任务" style="shape=ext;double=1;rounded=0;whiteSpace=wrap;html=1;" vertex="1" parent="WIyWlLk6GJQsqaUBKTNV-1">
          <mxGeometry x="100" y="770" width="155" height="150" as="geometry" />
        </mxCell>
        <mxCell id="7_roHs0swbESha7kOitr-21" value="&lt;span&gt;执行performSyncWorkOnRoot。注意，通过该函数来执行，并不会由scheduler来调度，而是会立即执行，因此这类更新也无法被打断&lt;/span&gt;" style="shape=ext;double=1;rounded=0;whiteSpace=wrap;html=1;" vertex="1" parent="WIyWlLk6GJQsqaUBKTNV-1">
          <mxGeometry x="294" y="770" width="156" height="160" as="geometry" />
        </mxCell>
      </root>
    </mxGraphModel>
  </diagram>
</mxfile>
